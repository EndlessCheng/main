比赛地址:
http://cstest.scu.edu.cn/soj/contest/contests.action
比赛情况:
除去前4题外,E,I分别有两个队AC.实际有效AC量=4.因为前4题是
听说有12级的小朋友要做特意加的放水的题,在计算过题量时应该
在心中去掉前4个题.


A-D:
水题,介绍了下并发时可能遇到问题,支持向量机,锐化,TF-IDF
参考资料:
<<并发的艺术>>
<<机器学习>>
<<数字图像处理>>
<<搜索引擎信息检索实践>>


E:
问 P / Q后第A位到第B位是多少,Q不超过100万,大数据不超过50,
1 <= B-A+1 <= 100.
显然P / Q是循环小数(或者有限),只需要找到循环节即可解决本问题.
在找循环节时用map可能会TLE,所以直接开个100万的数组就可以了.

要注意的是开的这个100万的数组不要每次都去memset一次,要根据
Q的大小去fill.


F:
给定两个区间,从两个区间各取一个数出来,求异或值,问最大的异或
值是多少,有多少种取法.

考察最高位x,使得B和D中至少有一个第x位为1.
如果A,C的x位都是1,那么可以知道答案的第x位为0,问题转换为
求A,B,C,D都把第x位去掉后的最大异或值及对应的计数.
否则,如果[A B], [C D]都包含了1<<x,那么答案一定是(1<<(x+1))-1,
对应的计数可以直接算出.
否则,对应的情况是一个区间使得x位为0,另一个区间使得x位为1,
可以转换为对应的子问题,求出来之后把子问题的最大值的x位置1即可.
注意边界情况的处理.


G:
根据soj3477改编.
求不超过A,但是翻转后不超过B的正整数的数目.
如果B的长度超过A的长度,则随便怎么翻转都满足要求,
这个时候答案就是A.
其它情况下,计算问题的反面:不超过A,但是翻转后大于B的.
根据满足要求的数的长度可以分为若干类.
每一类都是在求不超过一个上限,翻转后大于某个数的,额外条件是在这一类上
长度固定.
接下来递归地求就行了.
递归函数如下定义:
int64 LEQ_GREATER(char* A, int lA, int rA, int ta, char* B, int lB, int rB, int tb)
A,lA,rA表示了上限,B,lB,rB表示了下限,ta,tb表示两个比较标记.(实际上lA始终等于lB,rA始终等于rB)
其中A是高位在左边(lA是高位),而B是高位在右边(rB是高位).
每次递归的过程中就lA,rA位置上的数作出决策.
要注意的是第一位不能是0.
另外在和A的比较过程中,实际上A的低几位已经有个比较结果了,所以要引入ta表示低几位的
比较结果,这样才能作出决策.
tb同理.


H:
有两个任务,每个任务被分为不超过1000个子任务,子任务不可打断,并且不同
任务间子任务有依赖关系,问有多少种完成两个任务的可能性.

问题本质是有(N+1)*(M+1)的方格,有一些方格是不可到达的,从(0,0)到(N,M)有
多少种走法.

对每个约束标记一下不可达方格显然会TLE.注意到每个约束都会导致一个
矩形区域内的点不可达,于是可以考虑从上到下或从左到右扫描这些方格.
同时维护当前扫描到的方格上哪些是不可达的.而约束就成了扫描线上的事件了,
在恰当的时候加入,恰当的时候离开.扫描线之间作状态转移即可.


I:
给定序列,序列上的点是0或1,在子序列上有翻转操作,动态询问
A[i] = 0, A[j] = 1, LEFT < i < j <= RIGHT的数目,其中LEFT,RIGHT动态给出.

裸的线段树,树结点上维护0的个数,1的个数,01pairs的个数,10pairs的个数,延迟
标记即可.

另外注意一下signed int溢出.

J:
题目描述了一种压缩算法,要求模拟算法.

从左往右扫描,字符被分为已处理和未处理的.首先找到未处理字符串最长前缀
使得在已处理的字符串中出现.在反向构建了sa,ha的情况下还需要维护一个序列,
序列的第i个点为1,当且仅当rank为i的前缀已经被处理(翻转后这里就是前缀了).
在有这些结构的情况下就能找到最长前缀了,只需要枚举未处理字符串最长前缀即可.
在知道最长是多长的情况下,再暴力找出最前的即可,直接开个数组就可以知道某个
rank对应的前缀是否已经出现过了.通过sa可以还原出来对应的前缀位置.
这样做可以过,复杂度不可考.

总共求了个后缀数组,高度数组,用于求最长公共前缀的线段树,用于维护出现过的rank的
数状数组.


K:
题目要求将四则去处表达式转为lisp的,转换方法已经给出.

题目描述中已经给出了lisp的美化排版方法,难点在于把连续的加法或乘法放在一起.
这个实际上就是把语法树中相邻的+或*分别替换为一个,在语法树上dfs即可.
语法树的构造需要递归下降.

有兴趣可以读一下我写的关于组合性优先级声明的文章.


L:
给定一个无向连通图,一条边至多在一个环内,问任意两点间的简单路径的个数.

要注意起点终点相同的情况下,答案始终是1.另外再想一下,可以知道答案始终是2的方幂.
在dfs过程中,在某个时候,会遇到已经访问过的点,这个时候意味着出现了一个环,
可以把这个环的第一条边的权设置为1,而会遇到访问过的点的这条边从图中删除掉.
其它边的权设置为0.
这相问题就转换为求两点间的最短路了.

但是,在两个点的LCA附近可能出现问题,有些环可以没被计算在内.
这个时候,只需要把最短路径上离LCA最近的边找出来,再讨论一下就行了.

实际上边被分为四种:割,环上权为1的边,权为0的边,被删除的边,只要维护这些东西就能
解决很多cactus图上的问题了.

为了求出LCA附近的边还用step[i][j]记录了i点向根走第2^j条边的id.这样求出
LCA后就可以快速求出LCA附近的边了.
