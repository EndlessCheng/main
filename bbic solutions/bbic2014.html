<html>
<head>
<meta charset="gb2312"/>
<style type="text/css">
body {
   font-family: "微软雅黑", sans-serif;
   min-height: 800px;
   background-color:#fff;
   color: #000;
}
.solution {width:1024px;}
</style>
<script type="text/x-mathjax-config">
   MathJax.Hub.Config({
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
         inlineMath: [ ["$","$"], ["\\(","\\)"] ],
         displayMath: [ ["$$","$$"], ["\\[","\\]"] ],
         processEscapes: true
      },
      "HTML-CSS": { availableFonts: ["TeX"] }
   });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>
</head>
<body>

<div class = "solution">
<h2>Hanoi</h2>
<h4>题目大意</h4>
$\quad$汉诺塔问题可以在$2^n-1$步求解.问对于$1\le m \le 2^n-1$, 这一步移动后汉诺塔的状态, 这一步是将哪个盘子从哪个柱子移动到哪个柱子上.盘子的编号是$0$到$n-1$,小的盘子编号较小.
<h4>分析</h4>
$\quad$注意到$m$的第$n-1$位$0$的时候(二进制位,从0开始计数),盘子$n-1$在柱子$0$上,否则在柱子$2$上.
<br/>
$\quad$将这个观察一般化, 最开始, 我们的问题是第$n-1$个盘子在$from$上, 目标是要到$to$上. 当$m$的$n-1$位为0, 我们的问题转换为第$n-2$个盘子在$from$上, 目标是要到$3-from-to$上. 否则, 我们的问题是第$n-2$个盘子在$3-from-to$上, 目标是要到$to$上. 这样的扫描就可以还原出第$m$步后的汉诺状态了.
<br/>
$\quad$考虑第$m-1$步后的状态(也就是第$m$步前的状态). 设$m-1$的最低的值为$0$的位是第$idx$位,那么在第$m$次移动就是移动$idx$位对应的盘子. 因为低于$idx$位都是$1$, 意味着对应的盘子都在目标位置上. 这个$idx$也是$m$的最低的值为1的位. 在上述扫描中, 扫描到对应位的时候, 记录一下$from$和$to$的值, 就知道第$m$步是把第$idx$个盘子从$from$移动到$to$上了.
</div>

<div class = "solution">
<h2>Tiling</h2>
<h4>题目大意</h4>
$\quad$用$1*2$的多米诺牌拼成$4$行$N$列的矩形,但是不存在某条垂线,这条直线会将矩形分为两部分且不会把任何多米诺牌分为两部分.问拼成这样的矩形有多少种方法.
<h4>分析</h4>
$\quad$设当前需要铺第$i$列,前面$i-1$列已经铺满,$start$是铺满前$i-1$列时第$i$列的状态. $start$的第$j$位为1对应第$j$行已经被多米诺牌占据.用$next$表示第$i+1$列的状态,$mask$表示第$i$列的每一行是否已经铺过.($mask$的初值为$start$).维护这几个量按行dfs,我们可以知道在第$i$列的初值为$start$的时候,铺满第$i$列,且第$i+1$列的状态是$next$有多少种方法,记为$mat[next][start]$.
<br/>
$\quad$mat的第1列第$x$行就是$n=1$的时候,填满第$1$列,第$2$列的状态是$x$的方法数,记为列向量$x_0$,于是$x_{i+1} = mat * x_{i}$. 根据题意,在这里状态转移矩阵第$1$列应该强制设置为$0$,即$mat[*][0]=0$. 对于$n$, $x_{n-1}[0]$就是答案.
<br/>
$\quad$在此基础上,最后发现答案就是$1, 1, 4, 2, 3, 2, 3, 2, 3, ...$所以题目中的$1000000007$是坑人的.
</div>

<div class = "solution">
<h2>Number Game</h2>
<h4>题目大意</h4>
$\quad$取循环节不超过$100$的序列的长度不超过$10000$的连续子序列.两个人在这个子序列上轮流从头或从尾取走一个数,且以数字和最大为优化目标.
<br/>
$\quad$对于固定的循环序列,可能在上面取$10000$次子序列,询问对于该子序列先手的得分.
<h4>分析</h4>
$\quad$设循环节长度为$N$,序列为$s$,如果我们知道$s[i..j],0 \leq i < N, i \leq j < 10000$应的解$dp[j][i]$,对任何询问我们总可以转换为某个$dp[j][i]$.
<br/>
$$
\begin{cases}
当N \le j, 0 \le i \le N-2时,dp[j][i]依赖于dp[j-1][i], dp[j][i+1], \\
当N \le j, i=N-1时,dp[j][i]依赖于dp[j-1][i], dp[j-N][0], \\
当j < N, i < j时,dp[j][i]依赖于dp[j-1][i], dp[j][i+1], \\
当j < N, i = j时,目标序列只有一个元素
\end{cases}
$$
$\quad$于是我们在$O(N*10000)$的时间空间复杂度内完成dp数组的计算,对于每个询问$O(1)$回答.
<br/>
$\quad$总之,本题充分利用循环节不大的条件求解.

</div>

<div class = "solution">
<h2>Range Sum Query</h2>
<h4>题目大意</h4>
$\quad$给定齐次线性递推序列$L$,给定长度不超过$50000$的序列$X$(初始情况下所有的元素的值是0).在序列$X$上有两种操作.
<br/>
$\quad$1.给定$l,r$求$X$在该区间上的数的和.
<br/>
$\quad$2.给定$l,r,s$将$L[s]$加到$X[l], L[s+1]$加到$X[l+1]$, 直到对$X[r]$也加上对应的项为止.
<br/>
$\quad$所有结果对$1000000007$取模.
<h4>分析</h4>
$\quad$回忆一下类似的序列操作的题,一般都是用线段树解决,当需要操作的区间和当前结点对应的区间相同的时候,就直接在上面应用操作,并且留下一个标记,表示有操作到子结点的时候需要将标记应用到子结点上. 有很多类似的题目了, 只是这些题目的一般性不够, 本题只是将这种一般性提升到齐次线性递推序列上而已. 解法不变.
<br/>
$\quad$给定递推关系,满足该递推关系的序列的每一项只由序列的开始$5$项决定. 不妨设$L$的前五项是$x_1, x_2, x_3, x_4, x_5$, 则$L[i] = \sum_{j=1}^5 K_{i,j} * x_j$, 其中$K_{i,j}$和具体的序列无关. 同样的, 记$SL[i] = \sum_{j=1}^{i} L[j]$, $SL$的每一项也只由$L$的前$5$项决定:$SL[i] = \sum_{j=1}^5 SK_{i,j} * x_j$.
<br/>
$\quad$在此基础上我们引入一个工具方法value_at,输入是满足该递推式的前$5$项,能返回任意项的值. 同样的,我们还可以引入一个工具方法sum_at,输入是满足该递推式的前$5$项,能返回任意前缀的和.由于操作区间长度不超过$50000$,所以为了实现value_at,只需要知道$K_{i,j}, 1 \le i \le 50000, 1 \le j \le 5$.
对于sum_at也只需要知道$SK_{i,j}, 1 \le i \le 50000, 1 \le j \le 5$
<br/>
$\quad$线段树的update操作如下定义,$root$是结点,$l,r$表示对应的区间端点,$a,b$表示需要操作的区间,$l \le a \le b \le r$,数组$val$表示$a,b$区间上需要加的前$5$个数.
<br/>
$\quad$当$a=l, b=r$的时候表示操作结点和当前结点相同,直接利用sum_at方法可以更新当前区间的和. 并且可以留下懒标记, 表示当前区间的第$1$个数的值增加了$val[1]$, 第$2$个数增加了$val[2]$. 如果当前区间已经有过懒标记了, 没有问题, <font color = "red">原有懒标记和新的操作对应的标记相加即可, 这是由齐次线性递推关系保证的.</font>
<br/>
$\quad$递归到左右子树的时候, 对左子树, 可以直接利用当前结点的懒标记更新.对于右子树, 利用方法value_at计算出当前结点的懒标记应用到右子树上的时候的新懒标记,然后再应用到右子树上.
<br/>
$\quad$最后,题目中的$s$可能很大,对于这样的query,直接利用矩阵2分可以计算出$L[s], L[s+1], ..., L[s+4]$
<h4>参考题目</h4>
$\quad$<a href="http://codeforces.com/contest/446/problem/C" target="_blank">Codeforces Round #FF DZY Loves Fibonacci Numbers</a>
</div>

<div class = "solution">
<h2>Xor Zero</h2>
<h4>题目大意</h4>
$\quad$给定$n$个左端点为$0$,右端点小于$1000000$的区间,区间个数不超过$100000$.从每个区间中取出一个整数,使得所有的区间中取出的数的异或值为0.问有多少种取法,答案对$1000000007$取模.
<h4>分析</h4>
$\quad$涉及位操作,尤其是异或的,我们通常会按位考虑这个问题.不妨设当前所有的区间的右端点从小到大排序,放在数组$data$中. 如果$data[n-1] = 0$那么答案是1. 否则我们总是能找到某个数$bit$,表示右端点可能的最高位的位置.
<br/>
$\quad$用$dp[i][j] (0 \le i < n, j = 0, 1)$表示从区间$0$到区间$i$有多少种取法使得$bit$位的值为$j$.当$i=0$的时候$dp[0][*]$可以直接计算. 当$i>0$的时候一方面可以计算出当前区间有多少种取法分别对$bit$位能贡献$0,1$, 结合$dp[i-1][*]$可以计算出$dp[i][*]$的值. 
<br/>
$\quad$设$\forall k \in [start, n), data[k] \ge 2^{bit}$, 这些区间的特点是能取到$[0, 2^{bit})$所有的数.考虑$i > start$,当$j > i$的时候,区间j取的数的$bit$位是$1$, 当$j < i$的时候, 区间$j$上取的数无限制. 这个时候, $j > i$的区间在$bit$位上的贡献是$0$的时候, $j < i$的区间上在$bit$位上的贡献也是0, 在低于$bit$的位上, 要求目标是$0$, 那么第$i$个区间上的取值是唯一的. $j > i$的区间在$bit$位上的贡献是$1$的时候, 道理相同. 从右往左扫描,这些取法可以在$O(n-start)$的时间复杂度中算出.
<br/>
$\quad$还剩$i = start$的情况没有考虑.如果$j > i$上的区间贡献是$1$, 那么$i$对应区间的$bit$位只能是$1$, 这个时候我们将$k >= start$的区间的右端点都减去$2^{bit}$转移到子问题上. 如果$j > i$上的区间贡献是$0$, 那么$i$对应区间的$0$位只能是$0$, 计算方法和$i > start$时一样.
<br/>
$\quad$整个算法复杂度是$O(log(10^6)*n*log(n))$.
<h4>参考题目</h4>
$\quad$<a href="http://poj.org/problem?id=3986" target="_blank">poj 3986 Math teacher's homework</a>(某年区域赛现场赛题目)<br/>
$\quad$Xor Zero是基于这个题目出的. 题意上是等价的:一方面Xor Zero是这个题目的特殊情况. 另一方面增加一个集合$[0, k]$计算出方法数,然后再减去增加集合$[0, k-1]$对应的解即可(此外还可以直接在算法上改,只是较为复杂一点).
</div>

<div class = "solution">
<h2>Cactus II</h2>
<h4>题目大意</h4>
$\quad$给定连通的仙人掌图, 边带权, 求最大匹配.
<h4>分析</h4>
$\quad$仙人掌图离树很近, 很多在树上的算法都可以搬到仙人掌图上来, 这里直接把树形dp搬到仙人掌图上来即可.
<br/>
$\quad$我们像dfs树一样,dfs这个图,在结点上记录两个值$dp[curr][0, 1]$. $dp[curr][1]$是该结点不在匹配中的最大匹配,$dp[curr][1]$是该结点在匹配中的最大匹配.
<br/>
$\quad$类似求有向图scc那样,dfs过程中一方面我们给每个结点给一个访问标号. 另一方面在dfs过程中维护访问栈,栈中不仅有访问的结点还有访问的边. 在这样的数据结构辅助下, dfs过程中就很好确定cactus的结构.
<br/>
$\quad$对于一个环, 设curr结点是整个环中第一个访问的结点, 环中最后一个访问的结点和curr结点的边记为特殊边. 从最后一个结点向前倒推. 我们记录4个值, [特殊边是否在匹配中]*[当前结点是否在匹配中], 这就完成了环上的dp. 对于$dp[curr][0]$根据curr在的每一个以curr为起始点的环对$dp[curr][0]$都有贡献.对于$dp[curr][1]$,我们需要考虑curr结点在哪个环上有匹配,匹配的是环的第一条边还是最后一条边. 固定环, 我们可以知道在该环上没有匹配到有匹配的增量. 对所有的环求最最大增量就可以在$dp[curr][0]$上加上这个增量得到$dp[curr][1]$. 增量为负也是合理的.
<br/>
$\quad$说实话,这题挺没有技术含量的.喜欢这个图是因为喜欢这种研究方式:树的结构很好,图则很复杂,为了解决复杂的问题,可以引入简单到复杂的一个过度,尝试推广.
<h4>参考题目</h4>
$\quad$<a href="http://cstest.scu.edu.cn/soj/problem.action?id=3932" target="_blank">soj 3932 Tim</a>
$\quad$<a href="http://cstest.scu.edu.cn/soj/problem.action?id=4237" target="_blank">soj 4237 Cactus</a>
$\quad$原本准备出一个cactus上的最短路问题的题目, 后来发现8中OJ上已经有了.<br/>
</div>

<div class = "solution">
<h2>Discrete Logarithm</h2>
<h4>题目大意</h4>
$\quad$求$a^x \equiv b \pmod{2^c}, c \in [1, 16], a \in [1, 2^c), b \in [0, 2^c)$的最小解, 如果没有解则输出-1.
<h4>分析</h4>
$\quad$关于离散对数的题目很多了,有个问题就是$\bmod{2^c}$上非0元素的乘法结构问题. $\bmod{N}$的结构可以转换为$\bmod{p^k}$的结构, 其中p是素数. 而$p \neq 2$的结构很好, 因为$p^k$是有原根的, 其乘法结构被原根在乘法下的结构决定, 即：归约到循环群结构问题上($p^e, e < k$这些元素忽略). 而$\bmod{2^c}$的情况就不太妙了, 本题就是考察这个情况.
<br/>
$\quad$$c \le 2$的情况很简单,直接暴力求解,所以我们设$c > 2$.
<br/>
$\quad$对于奇数$a$存在$\exists b, a \equiv (-1)^{\frac{a-1}{2}}*5^b$. 5的次数是$2^{c-2}$, 所以$\bmod{2^c}$的数被分为3部分:第一部分是$2^{c-1}$个偶数,第二部分是$a \equiv 1 \pmod{4}$的奇数$2^{c-2}$个, 第三部分是$a \equiv -1 \pmod{4}$的奇数$2^{c-2}$个. (联想到高斯素数,表为整数平方和等问题了. 另外这里还有个解决问题的思路, 既然不存在原根,那么就找若干个数,通过其循环群的直和来表示目标的结构. 这里实际上找的是$5$和$2^{c-1}$. 一方面$5$的次数足够大,另一方面$2^{c-1}$的次数足够小,所以最后的分解才足够简洁).
<br/>
$\quad$ 例如,对于$c=4$我们有
</br>
$\quad$ $1 = 5^0, 5 = 5^1, 9 = 5^2, 13 = 5^3$
</br>
$\quad$ $15=-5^0, 11=-5^1, 7 =-5^2, 3 = -5^3$
</br>
$\quad$ 如果$a$是偶数, 我们也可以直接暴力求解, 因为$a^x=2^{tx}*q^x$, 当$tx \ge c$的时候, $a^x = 0$. 因为$c$不大, 所以$x$很小就可以出现0了.
</br>
$\quad$ 如果$b$是偶数, 由于现在$a$是奇数且对$2^c$取模,所以无解.
</br>
$\quad$ 现在$a,b$都是奇数,我们设$a = ca * 5 ^ {va}, b = cb * 5 ^ {vb}, va = -1或1, vb = -1或1$, 于是方程是
</br>
$\quad$ $(ca*5^{va})^{x} = cb*5^{vb}$ 即: $ca^x*5^{va*x} = cb*5^{vb}$
</br>
$\quad$ $va = 0$的时候方程可以直接求解.
</br>
$\quad$ $ca = 1$的时候方程化简为$5^{va*x} = cb*5^{vb}$这要求$cb=1$,然后解方程$va*x=vb (mod 2^{c-2})$
</br>
$\quad$ $cb = 1$的时候求$va*x=vb \pmod{2^{c-2}}$的偶数解.
</br>
$\quad$ $cb = -1$的时候求$va*x=vb \pmod{2^{c-2}}$的奇数解.
</br>
$\quad$ 还有一个问题没有解决:如何求出$a = ca * 5 ^ {va}$中的va呢?由于$c$不大,所以可以直接打表. 至于方程$va*x=vb \pmod{2^{c-2}}$的求解,在打出对$a$的分解的表的时候,也顺便打出了$u$在$2^k$下的逆元,避免了用欧几里德算法再去求解.
<h4>参考题目</h4>
$\quad$<a href="http://cstest.scu.edu.cn/soj/problem.action?id=3944" target="_blank">soj 3944 HaibaraAi Number</a>
</div>


<div class = "solution">
<h2>Set Size</h2>
<h4>题目大意</h4>
$\quad$求$\left | \{A^x \bmod M\} \right |$, 其中$1 \le M \le 10^9, 0 \le A < M, x \ge 1$
<h4>分析</h4>
$\quad$题目意图在于分析对一般整数取模的时候,某个数的方幂在乘法下的结构.当$A$不超过$1$或$M$等于$1$的时候,结构非常简单,所以我们先把这样的情况忽略.
<br/>
$\quad$先看一个已知问题如果$gcd(A, M) = 1$,由费马小定理,欧拉定理,原根等理论已经回答了,存在某个$x$使得$A^x \equiv 1 \pmod{M}$也就是说经过一定的乘方后,值会回到$A$,目标集合的元素个数就是$A$模$M$的次数. A的乘方的结构由循环群刻画.
<br/>
$\quad$当$gcd(A, M) \neq 1$的时候,我们从简单情况开始讨论.
<br/>
<ol>
<li>先看$A$是一个素数$p$的情况.记$M=p^bN$,设$p^x \equiv y \pmod{M}$,根据同余的定义有$p^x-y=kp^bN$,当$x \ge b$的时候,可以在两边同时除以$p^b$,得到$p^{x-b}-\frac{y}{p^b}=kN$,进而有$p^{x-b} \equiv \frac{y}{p^b} \pmod{N}$.由于$N$中不含因子$p$,所以如果同余式左边继续乘以$p$,其结构是一个已知问题.所以$p$的方幂的结构是个$\rho$形的,从某个位置开始进入循环.</li>
<li>当$A$是素数的方幂$p^a$的时候,$A$的方幂也从某个位置后开始进入循环,其循环节长度是$\frac{L}{gcd(L,a)}$,其中$L$是$p$的方幂的循环节长度.令$inc$是最小的整数使得$a*(inc+1) \ge b$于是,在进入循环前的数的个数是$inc$.</li>
<li>我们记$A=B(\prod_{i=1}^{r} p_i^{a_i})$,其中$p_i$是M的素因子.首先考虑$B$的方幂,从第一个位置开始,就是一个循环.再考虑$p_i^{a_i}$的方幂,从某个方幂开始才进入循环.所以$A$的方幂也会从某个位置开始进入循环,循环节长度是$B$和$p_i^{a_i}$的循环节长度的最小公倍数的因子(不是这个最小公倍数,考虑$A=6,M=10$,2和3的循环节长度都是4,但是A的循环节长度是1).而在进入循环前的数的个数是$max(inc_i)$.</li>
</ol>
$\quad$所以解法是一方面计算进入循环节前的数的个数,然后另一方面求出循环节的长度.求循环节的长度时只需要将这个最小公倍数进行分解,然后测试这些因子是不是循环节,然后得到答案.
<br/>
$\quad$从前面的分析可以知道对于某个素因子$p$有$L \mid \phi(N)$,更进一步有$\frac{L}{gcd(L,a)} \mid \phi(N)$,而$\phi(N) \mid \phi(M)$是显然的,再加上B的次数也是$\phi(M)$的因子.所以这个最小公倍数也一定是$\phi(M)$的因子.所以不必求出这个最小公倍数,而直接用$\phi(M)$的因子进行循环节长度测试(或者利用$\phi(M)$的素因子来分解这个最小公倍数),进而优化算法.
<br/>
$\quad$当$A$含有$M$的所有素因子的时候,A的方幂从某个时候开始值是0,这样的case可以特殊处理.
<h4>优化</h4>
$\quad$目前的算法在soj上的执行时间是7秒多,在发现只需要在$\phi(M)$的因子中寻找循环节长度后可以优化到5.4秒.所以需要更好的做法:代码由<a href = "http://lgarithm.github.io" target = "_blank">cauchy</a>给出,算法和原根的判断,费马小定理的卢卡斯逆命题有一定联系.费马小定理的卢卡斯逆命题:对正整数$n$存在整数$x$满足$x^{n-1}\equiv 1 \pmod{n}$且$x^{\frac{n-1}{q}}\not\equiv 1 \pmod{n}$,其中$q$是$n-1$的素因子,那么n是素数.该定理的不等式相关条件保证了$x$的次数是n-1,类似的,$gcd(A, M) = 1$时,我们得到求A的次数的算法:
<ol>
<li>初始化:$T = \phi(M)$</li>
<li>迭代:当$T \equiv 0 \pmod{q} 且 A^{\frac{T}{q}} \equiv 1 \pmod{M}$时,我们令$T = \frac{T}{q}$并进入下一次迭代,否则迭代结束(其中$q$是$\phi(M)$的素因子)</li>
<li>迭代结束时的T就是所求的次数</li>
</ol>
$\quad$所以优化的算法中我们将M分为两部分:$M=N0 \cdot N1$,其中$N0$是$M,A$共同素因子的方幂构成.那么$A$的若干次方幂对$N0$取模得到$0$.$A$在模$N1$的情况下有一个次数,答案就是这个次数加上得到$0$前的迭代次数.之前的分析也可以看出这个结论.
</br>
$\quad$注意到$N1 \mid M$和$\phi(N1) \mid phi(M)$(证明也参考之前的分析),我们可以优化$N1$的分解和$\phi(N1)$的计算.但是这个优化能起的作用不大,因为没有刻意构造$N1$分解复杂度大困难的case.
</br>
$\quad$优化后的算法也使得算法复杂度进一步明确.对于之前的代码复杂度不大好分析,因为对$\phi(M)$的因子个数不好估计.如果只估计因子个数最大值,那么得出来的复杂度很粗糙.在使用更好的做法之后,我们设将$M$分解为$N0$和$N1$的复杂度是$T0$,$M$最多的素因子个数是9,于是每个query的复杂度是O(T0+C9), C里面包含了求方幂的计数次数, 求整数次数中对每个素数的迭代次数.而对$M$和$\phi(M)$的分解,由200个query均摊.
<h4>进一步思考和阅读</h4>
$\quad$这里对$A^x$的分析结果和有理数的表示有关.因为一个有理数可以表示为有限小数或无限循环小数.本题中的循环从哪一位开始对应于有理数的循环节的开始位置,循环的长度对应于有理数的循环节长度,方幂等于0对应于有理数是有限的(或者说后面跟无限个0).关于有理数相关分析和结论参数<初等数论及其应用>(华章数学译丛 42 Kenneth H. Rosen著, 夏鸿刚 译)第12章的内容.
<br/>
$\quad$还记得<编程的本质>中的那啥吗?
<h4>离散对数问题</h4>
至此，知道了$A^x$的结构,不难设计出解决一般离散对数问题$A^x\equiv B\pmod{M}$的算法：
<ol>
<li>令$M=N0 \cdot N1$, 其中$N0, N1$的定义不变</li>
<li>设d是最小的整数使得$A^d\equiv0\pmod{N0}$</li>
<li>测试$i < d$时是否存在解，如果存在则输出解</li>
<li>这个时候我们的解为$x = d + y$,于是有$A^{d+y} \equiv 0 \pmod{N0}$,所以如果$B\not\equiv 0 \pmod{N0}$时无解</li>
<li>现在有$A^{d+y} \equiv A^d \cdot A^y \equiv B \pmod{N1}$由于$gcd(A,N1) = 1$所以两边同时乘以$A^{-d}$后使用常规baby-step-giant-step求解. (两边不同时乘以$A^{-d}$直接求$A^x\equiv B\pmod{N1}$中$x\ge d$的解可行吗?)
</ol>
整个过程和<a href="http://hi.baidu.com/aekdycoin/item/236937318413c680c2cf29d4" target="_blank">【扩展Baby Step Giant Step解决离散对数问题】</a>几乎是一致的.在这个算法中所有的tmp的乘积就是$N0$得到的方程是$\frac{A^{d1}}{N0}A^{y1}\equiv \frac{B}{N0}\pmod{\frac{M}{N0}=N1}$,由于$gcd(N0, N1) = 1$所以两边可以同时乘以$N0$得到$A^{d1}A^{y1}\equiv B\pmod{N1}$.其中的$d1$为AC原文中的d,在这里用$d1$和本文中的$d$以示区别. 
</div>

<div class = "solution">
<h2>Haskell</h2>
<h4>题目大意</h4>
$\quad$本题要求实现haskell的类型推导.为了简化问题, 引入了一个简化的语法.
<h4>分析</h4>
$\quad$该语言全部由函数声明组成, 每个函数声明由被声明的函数开头, 紧接着是形参列表, 然后是等号, 再接着是只有函数应用构成的表达式. 函数应用表达式中出现的标识符要么是形参,要么是当前正在声明的函数,要么是在此之前已声明的函数. 函数应用表达式中函数应用语法是左结合的, 无歧义的.
<br/>
$\quad$此外,我们还另外引入一个类型表达式,用来表达函数类型. 这个表达式是右结合的, 无歧义的. 在类型表达式中我们要么用Int表示一个基本类型,要么用一个标识符表示一个待定的类型(参数化的类型),要么通过->构造出函数类型.
<br/>
$\quad$在有了语言和类型表达式的基础上,我们为语言中引入的函数指定主类型:
<br/>
$\quad$1.基本类型规则:数的类型是Int
<br/>
$\quad$2.函数声明中的类型规则:
<br/>
$\quad$$\quad$2.1 将声明的等号左边看作一个表达式, 这个表达式和声明等号右边的表达式的类型匹配.
<br/>
$\quad$$\quad$2.2 柯里化:如果函数有多个形参,那么函数的输入类型是第一个形参的类型,输出类型是一个函数类型.这个函数类型的输入类型是第二个形参的类型,如此递归下去.
<br/>
$\quad$3.推断规则:函数的实参类型和函数的输入类型匹配. 
<br/>
$\quad$4.从已有声明中推断出尽可能多的信息来.一个函数的类型推断只考虑这个函数声明及其之前的其它函数声明.
<br/>
$\quad$整个系统还有一个内置的函数add,其类型是"Int->Int->Int".题目要求对每个函数声明先将这个声明输出然后再输出被声明的函数的主类型. 为了保证输出的唯一性, 主类型输出格式上有要求,一方面是用的括号要尽量少,另一方面是有类型变量命名规则.
<br/>
$\quad$首先对函数应用表达式的理解,即:生成该表达式的语法树.直接递归下降就可以生成.对于表达式s g h (a b), 我们生成的语法树是
<br>
<pre>
        i2
     i1     i3
  i0   h  a    b
s   g
</pre>
其中如果一个结点有两个子结点那么表示:左结点是一个函数,右结点是函数的参数,本结点是函数的返回值.其中i0,i1,i2,i3是对一些匿名结点的处理,通过引入一个内部名字来表示.
<br/>
$\quad$对于类型表达式我们也有类似处理比如: f a b c = *的声明中,f的类型结构是
<pre>
            f0
        u0        f1
              u1      f2
                  u2       f3
</pre>
$\quad$当一个结点具有两个子结点的时候,表示这个结点的类型是个函数类型,左边是输入类型,右边是输出类型.
</pre>
$\quad$当我们后序遍历函数应用表达式对应的语法树的时候, 就产生了一系列类型规则, 比如在上述语法树中遍历到结点i0的时候,我们产生规则g的类型和s的输入类型相同. 如果我们有一个系统, 存储了当前所有的函数的类型表达式, 那么将这个新的规则应用到这个系统(也称为一个Context)上即可.
</pre>
<br/>
$\quad$为方便起见我们对类型结点进行命名.key是结点名字,value是类型信息.类型信息可能标明该类型是一个基本类型,也有可能是一个被替换了的类型,存储了一个替换后的结点的名字,还有可能拥有输入类型名和输出类型名,这个时候结点是一个函数类型,最后一种可能是该结点没有输入类型和输出类型名,表明这是一个类型变量. 结点名分为两类,一类是具名结点,表示外部可以访问的结点,表示解析的结果,另一类是匿名结点,外部不可访问,主要是在应用类型规则或者是解析函数时自动产生.
<br/>
$\quad$在初始情况下,我们有一个基本的Context,里面的具名结点是Int和add. 每读入一个函数声明我们就为该函数的解析建立一个Context,参考基本的Context进行函数解析解析完成后把解析出来的结果复制到基本Context并输出解析结果.
<br/>
$\quad$现在来看如何在当前的解析Context中,依赖于参考Context,完成对函数的解析.显然,在初始情况下当前解析Context是空的.
<br/>
$\quad$1.为每一个形参,在当前解析Context中生成一个匿名的类型结点.
<br/>
$\quad$2.在当前解析Context中生成一个类型结点,名字是当前函数名.因为函数可能会递归调用.
<br/>
$\quad$3.生成右端函数应用表达式的语法树,然后在上面应用类型规则.
<br/>
$\quad$3.1如果当前的语法树结点没有子结点,则直接返回这个结点的类型.
<br/>
$\quad$3.1.1 令 name = 结点名.
<br/>
$\quad$3.1.2 如果name是形参,那么name = 对应匿名结点名
<br/>
$\quad$3.1.3 如果name在解析Context中则直接返回name.
<br/>
$\quad$3.1.4 如果当前结点是一个整数,那么name = "Int"
<br/>
$\quad$3.1.5 如果name不在参考Context中则出错
<br/>
$\quad$3.1.6 从参考Context中深复制名为name的结点放到解析context并返回name.
<br/>
$\quad$3.2如果当前语法树结点有子结点则一定有两个子结点,首先递归地得到两个子结点对应的类型结点名. 在解析Context中构造一个匿名结点s,表示当前结点类型.在解析Context中构造一个匿名结点x, 其输入类型是右结点的类型,输出类型是s. 在Context上应用匹配规则:左结点的类型和x的类型等价.
<br/>
$\quad$4.根据函数声明左端的结构,构造被声明的函数的类型. 右端的类型应该和被声明函数的"最终"返回类型匹配.
<br/>
$\quad$如果类型不出现递归,那么这个算法总是可以终止的.
<br/>
$\quad$现在还剩两个算法:在一个Context中引入match规则,从一个Context中深拷贝一个结点.
<br/>
match算法:
<br/>
$\quad$两个结点a,b要匹配首先要保证a,b不是中间结点,即:该结点被其它结点替换过,通过一个查找就能保证a,b两个结点不是临时性结点.
<br/>
$\quad$如果a和b相同,则返回.
<br/>
$\quad$如果a和b的输入类型都为空(输出类型自然为空),如果两个结点都是基本类型则断言两个基本类型相同,如果其中一个是基本类型则让不是基本类型的结点指向基本类型的结点,否则两个都是类型变量,让字典序小的指向字典序大的.
<br/>
$\quad$如果其中一个结点有子结点(表示一个函数),另一个结点没有子结点(表示一个类型变量),那么让类型变量结点指向函数类型结点.
<br/>
$\quad$如果两个结点都是函数,那么两个结点的左子树和右子树上分别应用match规则.
<br/>
类型深拷贝算法:
<br/>
$\quad$用一个map<string, string>表示从源Context拷贝过的结点,映射值为拷贝后对应的结点.
<br/>
$\quad$对应一个将被拷贝的结点name,首先该结点一定在源中存在,其次如果结点被替换过,那么拷贝该结点是没有意义的,这个时候可以直接找到被替换后的结点.
<br/>
$\quad$如果结点被拷贝过,那么直接返回拷贝后的新结点名.
<br/>
$\quad$当前Context中生成一个结点表示name拷贝后的结点x, 如果name有子结点,则拷贝对应的子结点,并令x对应子结点为这些拷贝后的子结点.最后返回x表示拷贝后的结点.
<br/>
$\quad$这里还有个问题,拷贝后的结点在新的Context中都是匿名的,所以,有必要的话,生成一个具名结点,指向拷贝后的匿结点.
<br/>
$\quad$至于如何输出类型表达式,且保证括号最少,这个很简单.还有类似的题目: 
<a href="http://cstest.scu.edu.cn/soj/problem.action?id=3815" target = "_blank">soj 3815 Simplify the Expression</a>
<a href="http://cstest.scu.edu.cn/soj/problem.action?id=3888" target = "_blank">soj 3888 parenthesis</a>至于如何应用规则对类型变量进行命名也是很简单的事.只是要注意最终返回类型可能不是类型变量而是Int,不需要命名为t.
<br/>
总结:<br/>
$\quad$其实这里给出了一个合一算法的实现. 合一算法本身的复杂度是指数级的. 因为很容易就可以构造出来一些类型,其结构长度是输入长度的指数级. 但是在实际应用中, 没有这些bad case, 基本上是线性的. 这里的实现大量使用字符串,map,通过在类型结点中引入一个字段指向其它字段来实现"合一".对于题目的规则,这样的实现足够了.
<br/>
$\quad$这里引入不同的Context可以解决大量临时结点的问题.只有当前解析Context才会出现大量临时结点,从中拷贝出来到目标中的时候,临时结点都被忽略了,只省下需要的东西. 但是这样做有个坏处, 大量类型具有相同子结构的时候,不能结构共享. 不能共享也使得目标Context中的类型总是保证一种很清爽的结构:可以被命名结点划分为不同的树,不同的命名类型之间不会有结点共享,互不影响.
</div>
</body>
</html>