A: Lambda-Calculus
这个题来源是lambda演算,参考资料是<<类型与程序设计语言>>.
实际上程序的要求就是实现lambda演算,测试例子为church布尔式,church数值的运算
对复杂表达式的解析要求不高.
1.递归下降生成语法树;
2.按要求的条件进行归约,由于限制,只要是出现application的地方就可以进行归约,并得到相同的结果,所以任何时候都可以进行归约;
3.归约时,只要对所有的application中用右端替换L.所限定的变量即可,注意变量同名的时候(Lx.Lx x) y,内部变量会隐藏外部的,所以不能进行;
4.输出时注意要求.



B: Type Derivation
这个题的来源在题目中说清楚了,主要是计算优化.
标程是规矩地生成语法树,计算类型.实际上,不用这么复杂.
第一步,分析,表达式,只保留最后一个,表达式.
第二步,去掉函数调用.
第三步,看一下最后的表达式中出现过哪些类型的矩阵,然后就可以输出类型了.



C: Distance
这个题的来源是凸优化.在一个解集中,找某个最优解,什么时候解才存在,什么时候是唯一的.
在这里,由于距离的定义改变了,所以解的唯一性没有了保证.
直接讨论的话情况很复杂.
所以要跳出这个讨论.
从另一个角度看,无论怎么化简,由于是线性的,只能在端点处取极值.
于是问题就迎刃而解.
|x-x0|+|y-y0|
= |x-x0|+|(-c-ax)/b-y0|(b不为零,b为零时消x,最后的结果一样)
= |x-x0|+|(-a/b)x-c/b-y0|

abs(a) = abs(b)时
等价在直线上找一点,到给定的两点距离最小.
1.给定两点重合,最小距离为0,唯一解.对应于ax0+by0+c=0的情况;
2.不重合,在这两点间取得最小距离,解不唯一,这时abs((ax0+by0+c)/a)=abs((ax0+by0+c)/b);

abs(a/b) != 1时
总是可以根据x的范围,将表达式写出来.
可以知道,无论怎么样,表达式肯定是x的一次函数,故必定在那个段的端点处取得最小值,且解是唯一的.
min(abs((ax0+by0+c)/a), abs((ax0+by0+c)/b);
(min(abs((ax0+by0+c)/a), abs((ax0+by0+c)/b)中的表达式分母为0时看作无穷大)



D: Area Coordinates I
E: Area Coordinates II
给定定义在一个区域上的函数f(x, y),比如一个描述波的函数.
其本身的性状是比较复杂的.
于是我们把区域分为很多小三角形,如果三角形够多.那么这个函数限定在小三角形上就是线性的.
现在的问题是,已经f在三角形三点处的值,找一个线性的函数g,使得这个函数在三点处的值和f相等
于是在三角形内部的值就可以用g的值代替f的值.
现在的问题是如何找这个g.

考虑这样的函数LA,LB,LC,LA在A处的值为1,在BC处的值为0,LB,LC类似.
f在A,B,C处的值分别为fa, fb, fc.
那么g = fa*LA+fb*LB+fc*LC.

一个点的面积坐标的第一个分量正好满足LA的需求...
于是这就好说了.

D题E题的输入要看清楚...很多人WA是因为这个.

若f(x, y) = x
可以得到
x = xa*LA+xb*LB+xc*LC
若f(x, y) = y
y = ya*LA+yb*LB+yc*LC
若f(x, y) = 1
1 = LA + LB + LC
所以E题的解就直接是用上面的前两两个式子了.

这也相当于一个变换,把A映射到(1, 0), B映射到(0, 1), C映射到(0, 0)
把变换求出来,求其逆变换也可以解.本质上是相同的.

很多人用海伦公式求面积,杯具啊.



F: A Funy Stone Game
这个游戏用另一种角度来看，可以将每一颗石子看作是一堆石子,如果它是第p堆中的石子，把么它所代表的这堆石子的个数为n-1-p。从而，操作变为拿走一个非0的石堆，并放入2个规模小于他的石堆(可以为0)。这便成了另一个游戏。之所以这么做是因为，转化后的游戏与经典的take&break游戏很相似。
因为石子堆是互不干扰的,因此这个游戏可以看作由若干个只有一堆石子的游戏组成。
先分析子游戏。求子游戏某状态x的SG函数值，我们需要它后继状态的SG函数值，子游戏的后继状态大多数为含有2堆石子的状态，不过2堆均小于x石子数。在了解石子数小于x的状态函数值的条件下，用SG定理可以求得任意后继状态的函数值。
用(p)表示只剩一堆规模为p的石子的状态，(p,q)表示剩下2堆石子，规模分别为p,q的状态。g (i，j) = g (i) xor g (j) ; g(i) = min{n∈  N | n ≠ g (p,q) for n ≥ p≥ 0 且 n ≥ q ≥ 0}。
应用以上结论，我们可以递推求得子游戏任意状态的SG函数值。用SG定理可以求得和游戏的任意状态的SG函数值。SG=0,David可以保证他的胜利，否则就不行。至于策略，只要操作之后留下的状态SG值为0就行了。
时间复杂度分析：
以上算法包含O (n)个SG值的计算，计算每一个的时间最多为O(n2)，判断必胜状态需要O ( ∑Si )，寻找最优策略需要O (n3)的时间，综上,该算法的时间复杂度为O(n3+∑Si)。
更多内容在国家集训队的论文上(07王晓珂 	解析一类组合游戏)


G: Distribute The Apples III
2*(L-1)>N-K意味着如果有人要超过L,只有一个人超过L.
一种解法是DP:
数据范围迷人的dp,其实d[n][k][L]=d[n-1][k-1][L](第k人分1个)+d[n-2][k-1][L](第k人分2个)+...+d[n-i][k-1][L](第k人分i个)+...+d[n-L][k-1][L](第k人分L个),再注意边界。Dp实际与L无关，L只是一个参数。
一种解法是用排列组合:
首先给每个人发一个苹果把问题转换为N-K个苹果发给K个人,每个人不超过L-1个苹果.
不考虑L-1的限制,只是一个重组合问题.
然后把不满足要求的情况去掉.由于只能让一个人超,所以不妨先让第一个人达到L个苹果,然后剩下的苹果又是重组合.
然后再乘以人数.就是所有非法的情况了.
再注意细节就能过了.



H: 1957 Number I
I: 1957 Number II
两个dfa的题,本来打算不要的...后来还是保留了.
资料
http://hi.baidu.com/%B3%E0%BA%AE%D0%F937/blog/item/37d33c395d24772cb8998f9d.html



J: The Winner
这是copy的题.
注意到如果排名第p的都能夺冠的话,那么自然想到排名第p-1的就可以(可以证明).
于是单调性满足了,二分答案之.
如果是p夺冠,那么找一个排名最靠前,且p能战胜的对手,战胜之.
一直这样贪心下去如果能进行完,就能夺冠,否则就不能.



K: Happy Children's Day
貌似是09年某公司的招聘题.
K卡在10000,是让大家水过的题.
标程的做法是:
长度为i的为3^i个,很容易确定长度.然后直接利用三进制,就可以确定答案了.
比如5,5>3所以就是长度为2的中的第5-3个,然后由于是从1开始数的,所以再减一个1得到1.
1对应的长度为2的三进制是01把0换成1,1换成6就解出来了"16"



L: Drawing Lines
这个题是阴人的.
首先是一大堆描述来阴人.
然后把n限制到20来阴人(如果不是20,大家很有可能去找规律)
接着把这n个点固定了来阴人.(挨骂吧)

由于画的线不是直线,因此次题与每个点的几何位置无关(点可以在平面上适当运动而不改变线的相交性).所以答案只与n有关.由EuLer公式,E=F+V-2,v=n,因此F最大时E最大,此时,平面图的每个面都应该只有3条边，否则可以对一个多边形进行三角形剖分来增加面数。当n=1,2是需要特殊考虑。另外，对于n个点，可以给出一种构造方法：先作一个三角形，以后每次在已有的三角形内加点。
以前证明:
r = e - n + 2(欧拉定理)
r * 3 = e * 2(在边最多的情况下,任意区域至多和三个边关联,否则在这个区域内,可以连接两个点那么就可以多一条边了.)
3 * r = 3 * e - 3 * n + 6
e * 2 = 3 * e - 3 * n + 6
e = 3 * n - 6


M: K Lovely Permutation
假设 长度为n的 置换p  满足有 m个循环节长度分别是
L1,L2,L3.....Lm,它满足k lovely permutation当且仅当 lcm(L1,L2,L3,...,Lm)==k
又因为 长度为n所以 L1+L2+L3+....+Lm==n
找出满足这两个条件的置换的个数。
第一个想法就是DP，用dp[j][s] j是循环节长度的lcm值为j,s表示循环节长度的和为s的置换个数，    可是 k的值很大所以j的值很大，不能直接暴力
注意  lcm(L1,L2,L3,...,Lm)==k  很显然  L1,L2,L3.....Lm是 k的因子  并且任意几个长度的lcm值也是 k的因子。
按增序找出  k的因子 ，f[i]为第i个因子   dp[j][s]  中的j就可以变成 循环节长度的lcm值为(k的第 j个因子)，循环节长度的和为s的置换的个数，状态数就减少了很多
(首先要知道长度为L的 一个循环节内部有(L-1)!种顺序)
于是可以得出递推式 (伪代码）      
                        for(i=0;i<cont,f[i]<=n;i++)  //cont为  k的因子个数
                        {
                             dp[id][s+f[i]]+=dp[j][s]*c[s+f[i]-1][f[i]-1]*  ((f[i]-1)!)   //           枚举最后位置的循环节长度 为f[i], id的值 为f[id]==lcm(f[j],f[i])，c[][]表示组合数;
                        } 
从  dp[j][s]转移到其它状态 只需要 在已经摆放好 的循环节后面再加一个 循环节就行了，这个长度是k的因子，扫描f[]就行了，于是很容易得出 dp[id][s+f[i]]+=dp[j][s]*c[s+f[i]][f[i]]*  ((f[i]-1)!)
//c[s+f[i]][f[i]]表示 从前s+f[i]个数里选出 f[i]个作为最后一个循环节。
这个错误在于 没有考虑顺序问题， 比如   置换 [1,2] [3,4,5]  和 置换 [3,4,5] [1,2]是同一个置换     这样就会重复计算，怎样解决这个问题呢，只需要把某一个指定的数固定在某一个循环节中就行了，为了方便

就把  s+f[i] 放在最后一个循环节中 ，然后从剩下的  s+f[i]-1个数中选择  f[i]-1个 放入最后一个循环节，问题就圆满解决了递推式

dp[id][s+f[i]]+=dp[j][s]*c[s+f[i]-1][f[i]-1]*  ((f[i]-1)!); 就是这样得出来的。