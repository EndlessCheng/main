---
layout: default
title: Solution To GCJ2015 R1A
categories: [gcj]
---

<h1>{{ page.title }}</h1>

<hr>
<h2>Mushroom Monster</h2>
<p>For the first method, if data[i] is greater than data[i+1] we add data[i] - data[i+1] to the answer<br/>
For the second method, we find the maximum value of data[i] - data[i+1] first, which is denoted by speed.<br/>
The maximum value means the minimum number of mushrooms Kaylin should eat in 10 seconds.<br/>
We add min(speed, data[i]) (0 <= 0 <= n - 1) to the answer.
</p>

<hr>
<h2>Haircut</h2>
<p>
Given a time X, we can compute the number of customers who have been cut hair or is being cutting hair,<br/>
which will be denoted as F(X). If a barber finishes cutting one customer's hair at that time, we<br/>
think the next customer is not being cutting hair. Find the smallest X such that F(X) >= n by binary searching.<br/>
Then we can consider situation when X-1 minutes finished, and compute the time a barber can serve for the<br/>
next customers. Sort the the barbers by the time and find the n-F[x-1] one.
</p>

<hr>
<h2>Logging</h2>
<p>
We can use brute force to solve the small test case.<br/>
For the large test case, imagine that a tree is on the convex hull after cutting some trees, there<br/>
must exist a line such that all the tree is on the line or lie in the same side of the line. By<br/>
enumerating all the possible lines and checking other trees position, we can cut all the trees on<br/>
one side of the line to make the trees on the line on the convex hull. From this observation we obtain<br/>
an algorithm of O(n^3). We can fix a tree and consider all the line through this tree together. Use<br/>
P[i] to denote the position of the ith tree. If P[i] is fixed, we sort all the other points by the<br/>
angle of vector P[x] - P[i]. Use Q to denote the sorted trees, we draw a line through point P[i] and<br/>
Q[0] first, which divides the trees into three classes. Then, we draw a line through point P[i] and<br/>
Q[1]. We can reuse the result of the previous drawing.
</p>
