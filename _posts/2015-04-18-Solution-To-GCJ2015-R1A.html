---
layout: default
title: Solution To GCJ2014 R1A
---

<h1>{{ page.title }}</h1>

<hr>
<h2>Mushroom Monster</h2>
<p>For the first method, if data[i] is greater than data[i+1] we add data[i] - data[i+1] to the answer<br/>
For the second method, we find the maximum value of data[i] - data[i+1] first, which is denoted by speed.<br/>
The maximum value means the minimum number of mushrooms Kaylin should eat in 10 seconds.<br/>
We add min(speed, data[i]) (0 <= 0 <= n -1) to the answer.
</p>

<hr>
<h2>Haircut</h2>
<p>
Give a time X, we can compute the number of customers who have been cut hair or is being cutting hair,<br/>
which will be denoted as F(X). If a barber finishes cutting one customer's hair at that time, we<br/>
think the next customer is not being cutting hair. Find the smallest X such that F(X) >= n by binary search.<br/>
Then we can consider situation when X-1 minutes finished, and compute the time a barber can serve for the<br/>
next customers. Sort the the barbers by the time and find the n-F[x-1] one.
</p>

<hr>
<h2>Logging</h2>
<p>
We can use brute force to solve the small test case.<br/>
For the large test case, imagine that a tree is on the convex hull after, there must exist a line such<br/>
that all the tree is on the line or lie in the same side of the line. By enumerating all the possible<br/>
lines and checking other trees position, we can cut all the trees on one side of the line to make the<br>
trees on the line on the convex hull. From this observation we obtain an algorithm of O(n^3).<br/>
We can fix a tree and consider all the line through this tree together. Use P[i] to denote the position<br/>
of the ith tree. If P[i] is fixed, we sort all the other points by the angle of vector P[x] - P[i].<br/>
Use Q to denote the sorted trees, we draw a line through point P[i] and Q[0], which divides the trees<br/>
into three classes. Then, we draw a line through point P[i] and Q[1]. We can reuse the result of the<br/>
previous drawing.
</p>
